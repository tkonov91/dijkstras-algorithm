Описание проекта

Данный проект представляет собой систему для оптимизации маршрутов между городами с учётом нескольких критериев:

+ длины маршрута (в километрах)
+ времени в пути (в минутах)
+ стоимости проезда (в рублях)

Система находит три оптимальных маршрута между двумя городами (по каждому критерию отдельно), а затем выбирает компромиссный маршрут на основе заданных приоритетов.

Структура проекта

route-optimizer/
├── src/
│   ├── Main.java              # Главный класс приложения
│   ├── Graph.java             # Реализация графа и алгоритма Дейкстры
│   ├── Parser.java            # Парсер входных данных
│   ├── ResultWriter.java      # Запись результатов в файл
│   ├── City.java              # Класс для представления города
│   ├── Road.java              # Класс для представления дороги
│   ├── Route.java             # Класс для представления маршрута
│   ├── Request.java           # Класс для представления запроса
│   └── Criteria.java          # Перечисление критериев оптимизации
├── input.txt                  # Входные данные (пример)
├── output.txt                 # Выходные данные
└── README.md                  # Этот файл

Формат входных данных
Секция [CITIES]
text
ID: Название_города
Пример:

text
1: Москва
2: Санкт-Петербург
Секция [ROADS]
text
ID1 - ID2: длина(км), время(мин), стоимость(руб)
Пример:

text
1 - 2: 700, 480, 800
Секция [REQUESTS]
text
Город_отправления -> Город_назначения | (Приоритеты)
Пример:

text
Москва -> Санкт-Петербург | (Д,В,С)
Обозначения приоритетов:

Д - длина (расстояние)

В - время

С - стоимость

Порядок символов определяет важность критериев от наиболее важного к наименее важному.

Формат выходных данных
Для каждого запроса выводится:

Три оптимальных маршрута по отдельности (по длине, времени, стоимости)

Один компромиссный маршрут, выбранный на основе приоритетов

Пример вывода:

text
ДЛИНА: Москва -> Санкт-Петербург | Д=700, В=480, С=800
ВРЕМЯ: Москва -> Санкт-Петербург | Д=700, В=480, С=800
СТОИМОСТЬ: Москва -> Санкт-Петербург | Д=700, В=480, С=800
КОМПРОМИСС: Москва -> Санкт-Петербург | Д=700, В=480, С=800
Алгоритмы и структуры данных
1. Алгоритм Дейкстры
Основной алгоритм для поиска оптимальных путей по каждому критерию:

Временная сложность: O(E + V log V), где E - количество рёбер, V - количество вершин

Используемая структура: приоритетная очередь (бинарная куча)

2. Структура графа
Тип графа: неориентированный взвешенный граф

Хранение: список смежности для эффективного обхода соседей

Вершины: города (по названию)

Рёбра: дороги с тремя весами (длина, время, стоимость)

3. Выбор компромиссного маршрута
Маршруты сортируются по приоритетам пользователя в следующем порядке:

Основной приоритет (первый в списке)

Вторичный приоритет (второй в списке)

Третичный приоритет (третий в списке)

Требования к системе
Java Development Kit (JDK) 11 или выше

Любая среда разработки, поддерживающая Java

Минимум 512 МБ оперативной памяти

Сборка и запуск
Способ 1: Компиляция через командную строку
bash
# Компиляция всех файлов
javac src/*.java -d bin/

# Запуск программы
java -cp bin Main
Способ 2: Использование скрипта
bash
# Для Linux/Mac
chmod +x run.sh
./run.sh

# Для Windows
run.bat
Способ 3: Использование IDE
Импортируйте проект в IntelliJ IDEA, Eclipse или другую IDE

Установите JDK 11 или выше

Запустите класс Main.java

Пример использования
Создайте файл input.txt в корне проекта с данными:

txt
[CITIES]
1: Москва
2: Санкт-Петербург
3: Нижний Новгород
4: Казань

[ROADS]
1 - 2: 700, 480, 800
1 - 3: 400, 250, 300
2 - 3: 1100, 700, 1200
3 - 4: 350, 300, 500
1 - 4: 800, 600, 1000

[REQUESTS]
Москва -> Санкт-Петербург | (Д,В,С)
Нижний Новгород -> Казань | (С,В,Д)
Запустите программу

Результаты будут сохранены в файл output.txt

Тестирование
Для проверки работоспособности предусмотрены следующие тестовые сценарии:

Прямой маршрут - между двумя городами есть прямая дорога

Маршрут через промежуточные города - требуется найти оптимальный путь через несколько городов

Разные приоритеты - проверка корректности выбора компромиссного маршрута

Обратные дороги - проверка двустороннего движения

Отсутствие пути - обработка ситуации, когда маршрут не существует

Особенности реализации
Эффективность: Использование HashMap для быстрого поиска городов по названию

Гибкость: Поддержка различных комбинаций приоритетов (6 возможных вариантов)

Масштабируемость: Возможность добавления новых критериев оптимизации

Удобство: Читаемый формат вывода результатов

Обработка ошибок: Корректная реакция на некорректные входные данные

Ограничения
Все расстояния, время и стоимость задаются целыми положительными числами

Названия городов могут содержать пробелы

Дороги являются двусторонними с одинаковыми параметрами в обоих направлениях

В системе не предусмотрена обработка временных ограничений или обходов