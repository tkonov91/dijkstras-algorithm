# Описание проекта #

Данный проект представляет собой систему для оптимизации маршрутов между городами с учётом нескольких критериев:

+ длины маршрута (в километрах)
+ времени в пути (в минутах)
+ стоимости проезда (в рублях)

Система находит три оптимальных маршрута между двумя городами (по каждому критерию отдельно), а затем выбирает компромиссный маршрут на основе заданных приоритетов.

## Структура проекта ##

├── src/ \
│ ├── Main.java # Главный класс приложения \
│ ├── Graph.java # Реализация графа и алгоритма Дейкстры \
│ ├── Parser.java # Парсер входных данных \
│ ├── ResultWriter.java # Запись результатов в файл \
│ ├── City.java # Класс для представления города \
│ ├── Road.java # Класс для представления дороги \
│ ├── Route.java # Класс для представления маршрута \
│ ├── Request.java # Класс для представления запроса \
│ └── Criteria.java # Перечисление критериев оптимизации \
├── input.txt # Входные данные (пример) \
├── output.txt # Выходные данные \
└── README.md # Этот файл \

## Формат входных данных #

### Секция [CITIES] ###

ID: Название_города

Пример: \
1: Москва \
2: Санкт-Петербург

###Секция [ROADS]###

ID1 - ID2: длина(км), время(мин), стоимость(руб)

Пример: \
1 - 2: 700, 480, 800

### Секция [REQUESTS] ###

Город_отправления -> Город_назначения | (Приоритеты)

Пример: \
Москва -> Санкт-Петербург | (Д,В,С)

**Обозначения приоритетов:**

Д - длина (расстояние) \
В - время \
С - стоимость

Порядок символов определяет важность критериев от наиболее важного к наименее важному.

## Формат выходных данных ##

Для каждого запроса выводится:

+ Три оптимальных маршрута по отдельности (по длине, времени, стоимости)
+ Один компромиссный маршрут, выбранный на основе приоритетов

**Пример вывода:**

ДЛИНА: Москва -> Санкт-Петербург | Д=700, В=480, С=800 \
ВРЕМЯ: Москва -> Санкт-Петербург | Д=700, В=480, С=800 \
СТОИМОСТЬ: Москва -> Санкт-Петербург | Д=700, В=480, С=800 \
КОМПРОМИСС: Москва -> Санкт-Петербург | Д=700, В=480, С=800

## Алгоритмы и структуры данных ##

### 1. Алгоритм Дейкстры ###

Основной алгоритм для поиска оптимальных путей по каждому критерию: \
Временная сложность: O(E + V log V), где E - количество рёбер, V - количество вершин \
Используемая структура: приоритетная очередь (бинарная куча)

### 2. Структура графа ###

Тип графа: неориентированный взвешенный граф \
Хранение: список смежности для эффективного обхода соседей \
Вершины: города (по названию) \
Рёбра: дороги с тремя весами (длина, время, стоимость)

### 3. Выбор компромиссного маршрута ###

Маршруты сортируются по приоритетам пользователя в следующем порядке:

+ Основной приоритет (первый в списке)
+ Вторичный приоритет (второй в списке)
+ Третичный приоритет (третий в списке)

## Пример использования ##

Создайте файл input.txt в корне проекта с данными:

[CITIES] \
1: Москва \
2: Санкт-Петербург \
3: Нижний Новгород \
4: Казань \
 \
[ROADS] \
1 - 2: 700, 480, 800 \
1 - 3: 400, 250, 300 \
2 - 3: 1100, 700, 1200 \
3 - 4: 350, 300, 500 \
1 - 4: 800, 600, 1000 \
 \
[REQUESTS] \
Москва -> Санкт-Петербург | (Д,В,С) \
Нижний Новгород -> Казань | (С,В,Д) \
 \
Запустите программу

### Результаты будут сохранены в файл output.txt ###

## Тестирование ##

Для проверки работоспособности предусмотрены следующие тестовые сценарии:

+ Прямой маршрут - между двумя городами есть прямая дорога
+ Маршрут через промежуточные города - требуется найти оптимальный путь через несколько городов
+ Разные приоритеты - проверка корректности выбора компромиссного маршрута
+ Обратные дороги - проверка двустороннего движения
+ Отсутствие пути - обработка ситуации, когда маршрут не существует

## Ограничения ##

+ Все расстояния, время и стоимость задаются целыми положительными числами
+ Названия городов могут содержать пробелы
+ Дороги являются двусторонними с одинаковыми параметрами в обоих направлениях
+ В системе не предусмотрена обработка временных ограничений или обходов

## Запуск: ##
**bash**
```
# Компиляция всех файлов
javac src/*.java -d bin/

# Запуск программы
java -cp bin Main
```
**Требования:**
Java 11 или выше \
 \
Файл input.txt в корне проекта

## Особенности реализации ##

+ Алгоритм Дейкстры с временной сложностью O(E + V log V)
+ Двусторонние дороги (неориентированный граф)
+ Приоритетная очередь для эффективного выбора вершин
+ Подробные комментарии в коде для понимания алгоритмов
+ Обработка ошибок при отсутствии городов или путей
